{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>You have found the Swiss Army Knife of battling form spam in your Symfony application!</p> <p>This bundle provides a ton of different mechanisms for detecting and stopping spammers, scammers and abusers using your forms for their nefarious purposes, and brings them all together in an easy to configure and easy to use profile system.</p> <p>The bundle is compatible with PHP 8.1+ and Symfony 6.3 or later.</p>"},{"location":"#features","title":"Features","text":"<p>This bundle provides you with a ton of methods to easily combat spam through tested and proven methods:</p> <ul> <li>Honeypot: Insert a hidden field in your forms that lures spambots into filling it in.</li> <li>Submit Timer: Reject forms that have been submitted unfeasibly fast or unrealistically slow.</li> <li>Banned markup: Reject text fields containing HTML or UBB tags.</li> <li>Banned phrases: Reject text fields containing signature phrases targeting your site.</li> <li>Banned scripts: Reject text fields that contain too many characters in scripts not     expected by the site owners, like Cyrillic (Russian), Chinese or Arabic.</li> <li>URL count: Reject text fields that contain more hyperlinks than plausible.</li> </ul> <p>It wraps all these methods in an easy to use and easy to apply profile system, allowing you to pick and match per form what methods are required.</p>"},{"location":"#global-features","title":"Global features","text":"<p>All components support stealth mode, which hides verbose errors showing the rejection reasons, and instead replaces them with a generic catch-all error at the form level.</p> <p>All components can run in passive mode, in which they do not actually block submission but otherwise do all logging and escalation as if they are. This enables you to evaluate impact before releasing invasive actions.</p> <p>The bundle can be disabled globally, which is usually what you want when doing functional testing.</p> <p>All validators are implemented as regular Symfony constraints with attributes, meaning you can also apply them to your Doctrine entities, API classes and everything.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the bundle: <pre><code>composer require omines/antispam-bundle\n</code></pre></p> <p>Symfony Flex will enable the bundle and provide a basic configuration file with samples at <code>config/packages/antispam.yaml</code>. With the default config no invasive actions are enabled.</p> <p>Tip</p> <p>Head over to the Quickstart to have your spam protection up and running within 5 minutes!</p>"},{"location":"#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"#why-is-there-no-way-to-enable-a-profile-globally-for-all-forms","title":"Why is there no way to enable a profile globally for all forms?","text":"<p>Because it\u2019s very dangerous and you\u2019re not likely to really want this.</p> <p>Plugging spam protection into all forms of your application is very well possible, but we cannot distinguish between forms in your contact form, CMS, customer portals and login forms. Accidentally enabling antispam methods that block HTML, foreign characters or slow form entry could be destructive to the user experience of your CMS, in which all those things are likely normal. So no, we do not provide an option that allows you to shoot your own foot in a way that will at some point in the future cause tons of unforeseen drama.</p>"},{"location":"#why-not-a-stable-version-number","title":"Why not a stable version number?","text":"<p>As a matter of principle we eat our own dog food, so we use this bundle internally on multiple projects. When putting it out there however it comes with the territory that feedback points out unforeseen issues. So we keep the major version at 0 until we feel sufficiently confident that the core API, DX and mechanisms are stable.</p>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#examples","title":"Examples","text":""},{"location":"advanced/#testing-your-application","title":"Testing your application","text":"<p>Antispam measures are all fine and great, until you start to write functional tests for your application and you discover after hours of debugging that all your form submissions are failing because your tests are actually behaving exactly like spambots on your own application, and being stopped by this bundle.</p> <p>It is recommended to disable the entire bundle when testing in the config: config/packages/antispam.yaml<pre><code>when@test:\n    antispam:\n        enabled: false\n</code></pre> But what if we actually want to test the anti-spam measures? Just enable it again for the test you are running: <pre><code>use Omines\\AntiSpamBundle\\AntiSpam;\n\n$antispam = static::getContainer()-&gt;get(AntiSpam::class);\n$antispam-&gt;enable();\n</code></pre></p>"},{"location":"advanced/#fake-pass","title":"\u201cFake pass\u201d","text":"<p>A spammer who sees success is a happy spammer. One of the problems we have to cope with these days is that some people actually consider it an effective strategy to pay people to randomly fill in forms on the internet. If actual people see their spam is rejected, they might actually want to try again. Let\u2019s discourage that.</p> <p>To lure the spammer into believing their spam was accepted and is going to be read, we have to enable <code>passive</code> mode on the form profile:</p> <p><pre><code>antispam:\n  profiles:\n    my_form:\n      passive: true\n\n      # Rest of your configuration\n</code></pre> Our form will now pass, regardless of the violations. We can however use the result of the last test, which is always stored in the <code>AntiSpam</code> class! <pre><code>#[Route('/contact')]\npublic function fakeSuccess(Request $request): Response\n{\n    $form = $this-&gt;createForm(ContactForm::class, options: [\n        'antispam_profile' =&gt; 'my_form',\n    ]);\n    $form-&gt;handleRequest($request);\n    if ($form-&gt;isSubmitted() &amp;&amp; $form-&gt;isValid()) {\n        if (!AntiSpam::isSpam()) {\n            // Only send an actual email if the form did not trigger\n            // spam detections!\n            $this-&gt;sendEmailTo('site-owner@example.org', $form-&gt;getData();\n        }\n        $this-&gt;addFlash('message', 'Form passed');\n    }\n\n    return $this-&gt;render('form.html.twig', [\n        'form' =&gt; $form-&gt;createView(),\n    ]);\n}\n</code></pre></p>"},{"location":"configuration/","title":"Configuration","text":"<p>When installing the bundle, the Symfony Flex recipe will add a default config file to use as a starting point at <code>config/packages/antispam.yaml</code>. The file is yours to change according to your needs.</p> <p>The bundle configuration is for the most part self-documented, and the annotated default configuration can be viewed from the Symfony console with: <pre><code>bin/console config:dump-reference antispam\n</code></pre></p> <p>Note that you can also view the resolved configuration during development: <pre><code>bin/console debug:config antispam\n</code></pre> The fields below the <code>antispam</code> bundle root key are detailed below.</p>"},{"location":"configuration/#enabled","title":"<code>enabled</code>","text":"<p>type: <code>boolean</code> default: <code>true</code></p> <p>Allows you to enable or disable the entire bundle. Its main purpose is to be able to disable the bundle during functional testing, where it may interfere with, or complicate, your test cases.</p>"},{"location":"configuration/#passive","title":"<code>passive</code>","text":"<p>type: <code>boolean</code> default: <code>false</code></p> <p>Default passive setting for all validators and form types of the bundle.</p>"},{"location":"configuration/#stealth","title":"<code>stealth</code>","text":"<p>type: <code>boolean</code> default: <code>false</code></p> <p>Default stealth setting for all validators and form types of the bundle.</p> On default global and profile <code>stealth</code> settings <p>The global and profile defaults for <code>stealth</code> are different on purpose. The global setting is applied to  validators and form types used separately, and will therefore default to acting like an actual validator, displaying the precise error in the right place. Within a profile they become part of a larger antispam measure, and are therefore stealthed, merging them together as a generic rejection message.</p>"},{"location":"configuration/#profiles","title":"<code>profiles</code>","text":"<p>Keyed map of profiles to be used throughout your application. Use profiles to cater for different use cases, as you may want to apply different antispam measures to a contact form than a registration form, which may both differ from a comment section form.</p> <p>Each profile supports the following options:</p>"},{"location":"configuration/#stealth_1","title":"<code>stealth</code>","text":"<p>type: <code>boolean</code> default: <code>true</code></p> <p>By default stealth mode is enabled for all forms. Change this property to disable it specifically per profile.</p>"},{"location":"configuration/#passive_1","title":"<code>passive</code>","text":"<p>type: <code>boolean</code> default: <code>null</code></p> <p>You can enable or disable passive mode explicitly per form profile, or leave it at <code>null</code> to follow the global setting.</p>"},{"location":"configuration/#default-config","title":"Default config","text":"<pre><code># Default configuration for extension with alias: \"antispam\"\nantispam:\n\n    # Global default for whether included components should cause hard failures\n    passive:              false\n\n    # Global default for whether included components issue verbose or stealthy error messages\n    stealth:              false\n\n    # Allows you to globally disable all bundle functions, specifically for functional testing\n    enabled:              true\n\n    # A named list of different profiles used throughout your application\n    profiles:\n\n        # Prototype: Name the profile\n        name:\n\n            # Defines whether measures in this profile issue stealthy error messages\n            stealth:              true\n\n            # Passive mode will not make any of the included checks actually fail validation, they will still be logged. Null inherits global setting\n            passive:              null\n\n            # Defines whether to disallow content resembling markup languages like HTML and BBCode\n            banned_markup:\n                html:                 true\n                bbcode:               true\n\n            # Simple array of phrases which are rejected when encountered in a submitted text field\n            banned_phrases:\n                phrases:              []\n\n            # Banned script types, like Cyrillic or Arabic (see docs for commonly used ISO 15924 names)\n            banned_scripts:\n                scripts:              []\n                max_characters:       null\n                max_percentage:       0\n\n            # Inject an invisible honeypot field in forms, baiting spambots to fill it in\n            honeypot:\n\n                # Base name of the injected field\n                field:                ~ # Required\n                attributes:\n\n                    # Prototype\n                    name:                 ~\n\n            # Verify that time between retrieval and submission of a form is within human boundaries\n            timer:\n\n                # Base name of the injected field\n                field:                _validation\n                min:                  3\n                max:                  3600\n\n            # Configure limits to number of URLs permitted in text fields\n            url_count:\n\n                # Maximum number of URLs accepted per text field\n                max:                  null\n\n                # Maximum number of identical URLs accepted per text field\n                max_identical:        null\n</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#profiles","title":"Profiles","text":"<p>TBD.</p>"},{"location":"features/#stealth-mode","title":"Stealth Mode","text":"<p>Stealth Mode is used to mask the actual reason a form or field value was rejected.</p> <p>The way Symfony\u2019s form and validator mechanisms work together is counterintuitive for how we expect antispam measures to work, as their errors are really verbose, informative and user friendly. That means the default validation failures are, in a way, giving hints to the spammers on how to bypass the antispam measures. That sounds like a bad idea.</p> <p>By default all profiles have <code>stealth</code> enabled. This means all errors on fields and forms are replaced by a single generic error on the form level, by default stating that \u2018technical issues\u2019 have prevented the form from being processed. You can disable <code>stealth</code> at the profile level to keep explicit errors at the violating fields.</p> <p>When using the bundle components without the profile system, they follow the global <code>stealth</code> setting at the root of the configuration. It is disabled by default.</p>"},{"location":"features/#passive-mode","title":"Passive Mode","text":"<p>Passive Mode makes the bundle components work without actually rejecting input.</p> <p>When enabled all validators and other components still generate errors as usual, following <code>stealth</code> rules where enabled. At the end of the process all errors are dropped, not hampering successful validation.</p> <p>All logging is still present, all events are still dispatched. This allows you both to evaluate form filtering rules, and to implement custom behavior such as \u201cfake pass\u201d.</p> <p>By default <code>passive</code> is disabled both at the form and component level.</p>"},{"location":"features/#quarantine","title":"Quarantine","text":"<p>Quarantine was removed from the base bundle and is left up to the implementor via events.</p>"},{"location":"features/#forms","title":"Forms","text":"<p>TBD.</p>"},{"location":"features/#validators","title":"Validators","text":"<p>TBD.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#basic-setup","title":"Basic setup","text":"<p>Install the bundle: <pre><code>composer require omines/antispam-bundle\n</code></pre> Symfony Flex will automatically enable the bundle, and run a recipe creating a basic configuration file in the right place for your project.</p> <p>Open it and it will look something like this between the comments:</p> <p>config/packages/antispam.yaml<pre><code>antispam:\n    profiles:\n        default:\n            honeypot: email_address\n            timer:\n                min: 3\n                max: 3600\n</code></pre> This defines a profile called <code>default</code>, which defines that any forms having the profile should insert a honeypot field called <code>email_adress</code>, and have timer protection rejecting forms submitted either within 3 seconds, or after more than 1 hour.</p> But my form already has an email_address field! <p>Don\u2019t worry about automatically generated field causing name conflicts, the bundle will detect this and create a unique name instead by appending a number. In this case the honeypot would become <code>email_address1</code> instead automatically!</p> <p>For the form that you want to protect, apply the profile in its options either when creating it: <pre><code>$form = $this-&gt;createForm(MyApplicationForm::class, options: [\n    'antispam_profile' =&gt; 'default',\n]);\n</code></pre> Or in its type definition\u2019s defaults: <pre><code>public function configureOptions(OptionsResolver $resolver): void\n{\n    $resolver-&gt;setDefault('antispam_profile', 'default');\n}\n</code></pre> THAT\u2019S IT! You should now already start noticing a severe decrease in spam submissions!</p> Not seeing an error when you manually try to submit a form too fast or too slow? <p>Symfony Forms by default only shows form level errors if you are using <code>{{ form(form) }}</code> to render it as a whole. If you use <code>{{ form_start(form) }}</code> instead you will need to ensure form level errors are also shown, either by adding <code>{{ form_errors(form) }}</code> or manually rendering them with something like this:</p> <pre><code>{% for error in form.vars.errors %}\n    &lt;div class=\"alert alert-danger\"&gt;{{ error.message }}&lt;/div&gt;\n{% endfor %}\n</code></pre> <p>Note that this is not a shortcoming of this bundle, and is in general a good idea to do. This bundle just exposes the issue because it cannot show errors on fields that are by definition hidden.</p>"},{"location":"quickstart/#tightening-the-noose","title":"Tightening the noose","text":"<p>While the default setup will already stop many bots and scripts, there is also a lot of manual spam going on, and the spammers and scammers do write bots that can bypass these common methods. After running with the defaults for a bit you will have some idea of the kind of spam still getting through.</p> <p>Let\u2019s investigate some of the more invasive options available. For the following example, we\u2019re protecting the contact form of a local toy store operating in southern France.</p> <p>First of all, spammers are usually trying to sell you stuff, meaning they probably want to get you to head over to a forged or real website. So a contact form submission with several links in there is usually quite suspicious. For our toy store, we do expect someone to sometimes email a link, asking if we also stock the item. More than 1 is unlikely, more than 2 pretty much implausible.</p> <p>Spammers also have issues with \u201clingual targeting\u201d. It\u2019s really unlikely that a real customer would ever fill in our contact form in Russian or Hebrew (1). Spambots regularly do, so let\u2019s forbid that.</p> <ol> <li>The chosen scripts are random for the sake of example. In the real world you would choose which scripts to add based     on actual spam getting through your forms unscathed.</li> </ol> <p>Lastly, we\u2019re a toy store, not a software company or a digital agency. People will not send us snippets of HTML. Spambots regularly do, in lame attempts at XSS or phishing. We\u2019ll ensure it\u2019s not accepted.</p> <p>So let\u2019s create a new profile <code>contact</code> specifically for the website\u2019s contact form: config/packages/antispam.yaml<pre><code>antispam:\n    profiles:\n        contact:\n            # We'll keep the honeypot and timer, they're non-invasive and\n            # highly effective\n            honeypot: email_address # (1)!\n            timer:\n                min: 3\n                max: 14400 # (2)!\n\n            # Reject content containing HTML or BBCode markup\n            banned_markup: true\n\n            # Reject forms that consist for more than half of Cyrillic\n            # (Russian) or Hebrew text\n            banned_scripts:\n                scripts: ['cyrillic', 'hebrew']\n                max_percentage: 50\n\n            # Reject form fields containing more than 2 URLs, or repeating\n            # identical URLs\n            url_count:\n                max: 2\n                max_identical: 1\n</code></pre></p> <ol> <li>Remember that the field name will automatically become <code>email_address1</code> or a higher number in case of a naming conflict.</li> <li>Toy stores attract kids , and they may get distracted or go away. Allowing 4 hours for a response might be fair!</li> </ol> <p>What happens now when you apply the <code>contact</code> profile to your contact form type:</p> <ul> <li>Your form will get automatically get 2 hidden fields injected:<ul> <li>A Honeypot called <code>email_address</code>, that will fail the form if it contains any value on submit.</li> <li>A Submit Timer cryptographically verifying the number of seconds between retrieving and   posting the form. Many spambots either submit a form within a single second, as they are in a rush to attack   millions of other sites, or they store the form so they can submit it hours, days or weeks later. The timer ensures   that the form is posted with a delay that is reasonable for a human filling it in, without spending days to do so.</li> </ul> </li> <li>All text fields on the form will get some extra validators injected:<ul> <li>A BannedMarkup validator that ensures no content that attempts to (ab)use HTML or   BBCode features is allowed.</li> <li>A BannedScripts validator blocks all fields which consist for at least 50% of   Cyrillic or Hebrew characters.</li> <li>A URLCount validator will block form submission if any of its text fields constain more   than 2 URLs, or if a single URL is repeated more than once. </li> </ul> </li> </ul> <p>Always consider carefully what is normal on your specific site!</p> <p>All anti-spam measures can backfire at some point, and trigger false positives that may hurt your or your client\u2019s interests. Blocking all Cyrillic (Russian) text in the contact form of a translation agency is a really bad idea.  Blocking all links also means your new sales opportunity can\u2019t say \u201cI want to have a similar site to  https://example.org\u201d. Even banning the phrase \u201cWE SELL VIAGRA\u201d could theoretically block someone requesting commercial help with a spammer sending them that message every hour.</p> <p>Be prudent about the measures you implement, and try to err on the side of caution. Remember that it\u2019s better to receive a single uncaught spam email per week than to lose a valuable customer every month.</p>"},{"location":"quickstart/#read-more","title":"Read more","text":"<ul> <li>Details on available features</li> <li>Configuration options</li> </ul>"},{"location":"form/honeypot/","title":"HoneypotType Field","text":"<p>The <code>HoneypotType</code> field is a text field being rendered invisible in your forms. It will raise a form validation error if any non-empty value is submitted.</p> <p>A honeypot is a concept in computing that exposes seemingly valid application elements, without documenting or showing them to human users. Therefore their usage is a reliable indication of abuse by scripts, bots or other malicious agents. In spam recognition, they are considered a powerful tool to detect forms being filled in automatically by automated agents.</p> <p>Tip</p> <p>The full list of options defined and inherited by this form type is available running this command in your app: <pre><code># replace 'FooType' by the class name of your form type\n$ php bin/console debug:form FooType\n</code></pre></p>"},{"location":"form/submit_timer/","title":"SubmitTimerType FIeld","text":"<p>TBD.</p>"},{"location":"validator/banned_markup/","title":"Banned Markup","text":"<p>Validates that a given string does not contain a configured type of markup. </p> <p>It can recognize HTML and BBCode.</p> <p>Can be applied to properties or methods.</p> How strict is the detection of the markup types? <p>Markup detection is loose on purpose, and will also flag \u201clame attempts\u201d that are not valid, while at the same time trying to keep the chance of false positives as low as possible. Spambots are not known to strictly adhere to internet standards so being really strict would only reduce effectiveness.</p>"},{"location":"validator/banned_markup/#basic-usage","title":"Basic Usage","text":"AttributesYAMLPHP <pre><code>namespace App\\Entity;\n\nuse Omines\\AntiSpamBundle\\Validator\\Constraints as Antispam;\n\nclass Message\n{\n    #[Antispam\\BannedMarkup]\n    protected string $content;\n}\n</code></pre> <pre><code># config/validator/validation.yaml\nApp\\Entity\\Message:\n    properties:\n        content:\n            - BannedMarkup:\n</code></pre> <pre><code>// src/Entity/Participant.php\nnamespace App\\Entity;\n\nuse Omines\\AntiSpamBundle\\Validator\\Constraints as Antispam;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadata;\n\nclass Message\n{\n// ...\n\n    public static function loadValidatorMetadata(ClassMetadata $metadata): void\n    {\n        $metadata-&gt;addPropertyConstraint('content', new Antispam\\BannedMarkup());\n    }\n}\n</code></pre> <p>Null values are always valid</p> <p>As with most of Symfony\u2019s own constraints, <code>null</code> is considered a valid value. This is to allow the use of optional values. If the value is mandatory, a common solution is to combine this constraint with NotBlank.</p>"},{"location":"validator/banned_markup/#options","title":"Options","text":""},{"location":"validator/banned_markup/#bbcode","title":"<code>bbcode</code>","text":"<p>type: <code>boolean</code> default: <code>true</code></p> <p>If set to <code>true</code> validation will fail if the given value contains tags resembling BBCode.</p>"},{"location":"validator/banned_markup/#groups","title":"<code>groups</code>","text":"<p>type: <code>array|string</code> default: <code>null</code></p> <p>It defines the validation group or groups of this constraint. Read more about validation groups.</p>"},{"location":"validator/banned_markup/#html","title":"<code>html</code>","text":"<p>type: <code>boolean</code> default: <code>true</code></p> <p>If set to <code>true</code> validation will fail if the given value contains tags resembling HTML.</p>"},{"location":"validator/banned_markup/#passive","title":"<code>passive</code>","text":"<p>type: <code>bool</code> default: <code>null</code>, defaulting to bundle configuration</p> <p>When in passive mode the constraint will not generate a validation error, but still dispatch its regular events.</p> <p>With default bundle configuration passive mode is disabled.</p>"},{"location":"validator/banned_markup/#payload","title":"<code>payload</code>","text":"<p>type: <code>mixed</code> default: <code>null</code></p> <p>This option can be used to attach arbitrary domain-specific data to a constraint. The configured payload is not used by the Validator component, but its processing is completely up to you.</p> <p>For example, you may want to use several error levels to present failed constraints differently in the front-end depending on the severity of the error.</p>"},{"location":"validator/banned_markup/#stealth","title":"<code>stealth</code>","text":"<p>type: <code>bool</code> default: <code>null</code>, defaulting to bundle configuration</p> <p>With stealth mode disabled the validator will generate a verbose error, similar to Symfony built-in constraints, explaining for precisely which reasons what rule was validated.</p> <p>If stealth mode is enabled instead the validator only shows a generic error message, stating that form submission failed and the user should contact the website administrator for further assistance.</p> <p>With default bundle configuration stealth mode is disabled by default when used standalone, and enabled by default when applied as part of an anti-spam profile.</p>"},{"location":"validator/banned_phrases/","title":"Banned Phrases","text":"<p>Validates that a given string does not contain blacklisted phrases.</p> <p>Can be applied to properties or methods.</p>"},{"location":"validator/banned_phrases/#basic-usage","title":"Basic Usage","text":"AttributesYAMLPHP <pre><code>namespace App\\Entity;\n\nuse Omines\\AntiSpamBundle\\Validator\\Constraints as Antispam;\n\nclass Message\n{\n    #[Antispam\\BannedPhrases(['viagra', 'cialis'])\n    protected string $content;\n}\n</code></pre> <pre><code># config/validator/validation.yaml\nApp\\Entity\\Message:\n    properties:\n        content:\n            - BannedPhrases:\n                - viagra\n                - cialis\n</code></pre> <pre><code>// src/Entity/Participant.php\nnamespace App\\Entity;\n\nuse Omines\\AntiSpamBundle\\Validator\\Constraints as Antispam;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadata;\n\nclass Message\n{\n// ...\n\n    public static function loadValidatorMetadata(ClassMetadata $metadata): void\n    {\n        $metadata-&gt;addPropertyConstraint('content', new Antispam\\BannedPhrases(['viagra', 'cialis']));\n    }\n}\n</code></pre>"},{"location":"validator/banned_phrases/#options","title":"Options","text":""},{"location":"validator/banned_phrases/#groups","title":"<code>groups</code>","text":"<p>type: <code>array|string</code> default: <code>null</code></p> <p>It defines the validation group or groups of this constraint. Read more about validation groups.</p>"},{"location":"validator/banned_phrases/#passive","title":"<code>passive</code>","text":"<p>type: <code>bool</code> default: <code>null</code>, defaulting to bundle configuration</p> <p>When in passive mode the constraint will not generate a validation error, but still dispatch its regular events.</p> <p>With default bundle configuration passive mode is disabled.</p>"},{"location":"validator/banned_phrases/#payload","title":"<code>payload</code>","text":"<p>type: <code>mixed</code> default: <code>null</code></p> <p>This option can be used to attach arbitrary domain-specific data to a constraint. The configured payload is not used by the Validator component, but its processing is completely up to you.</p> <p>For example, you may want to use several error levels to present failed constraints differently in the front-end depending on the severity of the error.</p>"},{"location":"validator/banned_phrases/#stealth","title":"<code>stealth</code>","text":"<p>type: <code>bool</code> default: <code>null</code>, defaulting to bundle configuration</p> <p>With stealth mode disabled the validator will generate a verbose error, similar to Symfony built-in constraints, explaining for precisely which reasons what rule was validated.</p> <p>If stealth mode is enabled instead the validator only shows a generic error message, stating that form submission failed and the user should contact the website administrator for further assistance.</p> <p>With default bundle configuration stealth mode is disabled by default when used standalone, and enabled by default when applied as part of an anti-spam profile.</p>"},{"location":"validator/banned_scripts/","title":"Banned Scripts","text":"<p>Validates that a given string does not contain characters of the given script or scripts. </p> <p>A Script is the Unicode term given to what is commonly called a writing system. Well known examples include the Greek, Arabic, Cyrillic and Han scripts.</p> <p>The validator can fail on a minimum percentage or character count in the given value. With the default percentage of 0% the validator will fail if it encounters any character in any of the configured scripts.</p> <p>Can be applied to properties or methods.</p>"},{"location":"validator/banned_scripts/#basic-usage","title":"Basic Usage","text":"AttributesYAMLPHP <pre><code>namespace App\\Entity;\n\nuse Omines\\AntiSpamBundle\\Type\\Script; \nuse Omines\\AntiSpamBundle\\Validator\\Constraints as Antispam;\n\nclass Message\n{\n    #[Antispam\\BannedScripts([Script::Cyrillic]\n    protected string $content;\n}\n</code></pre> <pre><code># config/validator/validation.yaml\nApp\\Entity\\Message:\n    properties:\n        content:\n            - BannedScripts: [Cyrillic]\n</code></pre> <pre><code>// src/Entity/Participant.php\nnamespace App\\Entity;\n\nuse Omines\\AntiSpamBundle\\Type\\Script;\nuse Omines\\AntiSpamBundle\\Validator\\Constraints as Antispam;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadata;\n\nclass Message\n{\n// ...\n\n    public static function loadValidatorMetadata(ClassMetadata $metadata): void\n    {\n        $metadata-&gt;addPropertyConstraint('content', new Antispam\\BannedScripts(Script::Cyrillic));\n    }\n}\n</code></pre> <p>Null values are always valid</p> <p>As with most of Symfony\u2019s own constraints, <code>null</code> is considered a valid value. This is to allow the use of optional values. If the value is mandatory, a common solution is to combine this constraint with NotBlank.</p>"},{"location":"validator/banned_scripts/#options","title":"Options","text":""},{"location":"validator/banned_scripts/#groups","title":"<code>groups</code>","text":"<p>type: <code>array|string</code> default: <code>null</code></p> <p>It defines the validation group or groups of this constraint. Read more about validation groups.</p>"},{"location":"validator/banned_scripts/#maxpercentage","title":"<code>maxPercentage</code>","text":"<p>type: <code>int</code> default: <code>0</code></p> <p>Validation will fail if the given value contains more characters in the configured scripts than configured.</p> <p>Ignored if set to <code>0</code> and <code>maxCharacters</code> is also set.</p>"},{"location":"validator/banned_scripts/#maxcharacters","title":"<code>maxCharacters</code>","text":"<p>type: <code>int|null</code> default: <code>null</code></p> <p>Validation will fail if the given value contains more characters in the configured scripts than configured.</p> <p>Set to <code>null</code> to disable failing on absolute character count.</p>"},{"location":"validator/banned_scripts/#passive","title":"<code>passive</code>","text":"<p>type: <code>bool</code> default: <code>null</code>, defaulting to bundle configuration</p> <p>When in passive mode the constraint will not generate a validation error, but still dispatch its regular events.</p> <p>With default bundle configuration passive mode is disabled.</p>"},{"location":"validator/banned_scripts/#payload","title":"<code>payload</code>","text":"<p>type: <code>mixed</code> default: <code>null</code></p> <p>This option can be used to attach arbitrary domain-specific data to a constraint. The configured payload is not used by the Validator component, but its processing is completely up to you.</p> <p>For example, you may want to use several error levels to present failed constraints differently in the front-end depending on the severity of the error.</p>"},{"location":"validator/banned_scripts/#scripts","title":"<code>scripts</code>","text":"<p>type: <code>array|string|Script</code></p> <p>An array of <code>Script</code> values, or strings that can be parsed into a valid <code>Script</code> value. Scalars are wrapped in an array.</p> <p>For valid values refer to <code>Script.php</code> in the sources.</p>"},{"location":"validator/banned_scripts/#stealth","title":"<code>stealth</code>","text":"<p>type: <code>bool</code> default: <code>null</code>, defaulting to bundle configuration</p> <p>With stealth mode disabled the validator will generate a verbose error, similar to Symfony built-in constraints, explaining for precisely which reasons what rule was validated.</p> <p>If stealth mode is enabled instead the validator only shows a generic error message, stating that form submission failed and the user should contact the website administrator for further assistance.</p> <p>With default bundle configuration stealth mode is disabled by default when used standalone, and enabled by default when applied as part of an anti-spam profile.</p>"},{"location":"validator/url_count/","title":"URL count","text":"<p>Validates that a given string contains at most a defined number of URLs, or a limited amount of duplicated URLs.</p> <p>Can be applied to properties or methods.</p> How strict is the detection of URLs? <p>URL detection is loose on purpose, and will also flag \u201clame attempts\u201d that are not valid, while at the same time trying to keep the chance of false positives as low as possible. Spambots are not known to strictly adhere to internet standards so being really strict would only reduce effectiveness.</p>"},{"location":"validator/url_count/#basic-usage","title":"Basic Usage","text":"AttributesYAMLPHP <pre><code>namespace App\\Entity;\n\nuse Omines\\AntiSpamBundle\\Validator\\Constraints as Antispam;\n\nclass Message\n{\n    #[Antispam\\UrlCount(max: 3, maxIdentical: 1]\n    protected string $content;\n}\n</code></pre> <pre><code># config/validator/validation.yaml\nApp\\Entity\\Message:\n    properties:\n        content:\n            - UrlCount:\n                max: 3\n                maxIdentical: 1\n</code></pre> <pre><code>// src/Entity/Participant.php\nnamespace App\\Entity;\n\nuse Omines\\AntiSpamBundle\\Validator\\Constraints as Antispam;\nuse Symfony\\Component\\Validator\\Mapping\\ClassMetadata;\n\nclass Message\n{\n// ...\n\n    public static function loadValidatorMetadata(ClassMetadata $metadata): void\n    {\n        $metadata-&gt;addPropertyConstraint('content', new Antispam\\UrlCount(max: 3, maxIdentical: 1));\n    }\n}\n</code></pre> <p>Null values are always valid</p> <p>As with most of Symfony\u2019s own constraints, <code>null</code> is considered a valid value. This is to allow the use of optional values. If the value is mandatory, a common solution is to combine this constraint with NotBlank.</p>"},{"location":"validator/url_count/#options","title":"Options","text":""},{"location":"validator/url_count/#groups","title":"<code>groups</code>","text":"<p>type: <code>array|string</code> default: <code>null</code></p> <p>It defines the validation group or groups of this constraint. Read more about validation groups.</p>"},{"location":"validator/url_count/#max","title":"<code>max</code>","text":"<p>type: <code>int|null</code> default: <code>0</code></p> <p>Validation will fail if the given value contains more URLs than configured.</p> <p>Set to <code>null</code> to disable failing on URL count altogether.</p>"},{"location":"validator/url_count/#maxidentical","title":"<code>maxIdentical</code>","text":"<p>type: <code>int|null</code> default: <code>null</code></p> <p>Validation will fail if any single URL in the given value occurs more often than configured.</p> <p>The default <code>null</code> setting disables counting URL repetition.</p>"},{"location":"validator/url_count/#passive","title":"<code>passive</code>","text":"<p>type: <code>bool</code> default: <code>null</code>, defaulting to bundle configuration</p> <p>When in passive mode the constraint will not generate a validation error, but still dispatch its regular events.</p> <p>With default bundle configuration passive mode is disabled.</p>"},{"location":"validator/url_count/#payload","title":"<code>payload</code>","text":"<p>type: <code>mixed</code> default: <code>null</code></p> <p>This option can be used to attach arbitrary domain-specific data to a constraint. The configured payload is not used by the Validator component, but its processing is completely up to you.</p> <p>For example, you may want to use several error levels to present failed constraints differently in the front-end depending on the severity of the error.</p>"},{"location":"validator/url_count/#stealth","title":"<code>stealth</code>","text":"<p>type: <code>bool</code> default: <code>null</code>, defaulting to bundle configuration</p> <p>With stealth mode disabled the validator will generate a verbose error, similar to Symfony built-in constraints, explaining for precisely which reasons what rule was validated.</p> <p>If stealth mode is enabled instead the validator only shows a generic error message, stating that form submission failed and the user should contact the website administrator for further assistance.</p> <p>With default bundle configuration stealth mode is disabled by default when used standalone, and enabled by default when applied as part of an anti-spam profile.</p>"}]}